<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>DreemGL by dreemproject</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">DreemGL</h1>
      <h2 class="project-tagline">DreemGL is an open-source multi-screen prototyping framework for mediated environments, with a visual editor and shader styling for webGL and DALi runtimes written in JavaScript, produced by Teeming Society with Samsung Electronics. http://teem.nu | http://samsung.com</h2>
      <a href="https://github.com/dreemproject/dreemgl" class="btn">View on GitHub</a>
      <a href="https://github.com/dreemproject/dreemgl/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/dreemproject/dreemgl/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="a-prototyping-toolkit-for-gpu-accelerated-multiscreen-development" class="anchor" href="#a-prototyping-toolkit-for-gpu-accelerated-multiscreen-development" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A PROTOTYPING TOOLKIT FOR GPU-ACCELERATED MULTISCREEN DEVELOPMENT</h3>

<p>More and more product opportunities and design problems involve prototyping applications that connect large screens in the environment to handheld devices or tablets.  At the same time, UI on these screens is evolving to take advantage of faster GPU capabilities.  Dreem is built to enable teams of designers and developers to collaborate on real, functional prototypes that explore both the power of accelerated graphical UIs and multiscreen user experiences.</p>

<h3>
<a id="iot-integration-for-smart-environments" class="anchor" href="#iot-integration-for-smart-environments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>IOT INTEGRATION FOR SMART ENVIRONMENTS</h3>

<p>DREEM allows developers and designers to create ‘compositions’, applications running across many screens and devices in the environment.  Compositions can include networks of users’ personal devices, handheld devices connected to the room, like remotes, and environmental sensors and actuators, like lighting systems.  Input can come from a range of services in the connected space, like depth cameras and physical controllers.</p>

<h3>
<a id="create-layouts-and-compositions-visually-using-real-data-from-network-services" class="anchor" href="#create-layouts-and-compositions-visually-using-real-data-from-network-services" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CREATE LAYOUTS AND COMPOSITIONS VISUALLY, USING REAL DATA FROM NETWORK SERVICES</h3>

<p>For designers, the development environment includes tools to layout screens visually and preview them in live GL contexts.  Prototype developers and users can connect data services to experiences running on big screens, extend controls to multiple handhelds, and utilize IoT devices all from a visual composition editor.</p>

<h3>
<a id="multiple-users-multiple-roles-in-many-spaces" class="anchor" href="#multiple-users-multiple-roles-in-many-spaces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MULTIPLE USERS, MULTIPLE ROLES, IN MANY SPACES</h3>

<p>Prototypes built in DREEM are meant to allow designers to easily test compositions that connect multiple users in shared experiences on big screens or projections, while allowing each person to use the control tools and preferences they have configured.  Compositions can include many roles that user dynamically choose as they join the shared experience</p>

<hr>

<h2>
<a id="using-dreemgl" class="anchor" href="#using-dreemgl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using DreemGL</h2>

<p>DreemGL is an open source JS webGL and DALi (Dynamic Animation Library; a cross-platform 3D UI Toolkit) prototyping framework with
shader styling and render functions.
<img src="https://raw.githubusercontent.com/dreemproject/dreemgl/dev/docs/images/architecture.png" alt="Architecture Image"></p>

<h2>
<a id="start-dreemgl" class="anchor" href="#start-dreemgl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Start DreemGL</h2>

<p>To start DreemGL type:</p>

<p><code>node server.js</code></p>

<p>To view the Intro presentation, click here:</p>

<p><a href="http://127.0.0.1:2000/docs/slides/introduction">http://127.0.0.1:2000/docs/slides/introduction</a></p>

<p>To try livecoding a shader open this:</p>

<p><a href="http://127.0.0.1:2000/test/rendertest">http://127.0.0.1:2000/test/rendertest</a> and open
<a href="/test/rendertest.js">./test/rendertest.js</a> in your editor and start typing away and saving, reload should
be live.</p>

<p>As the server starts, it also shows other local IP's its listening on (for trying it on your phone)</p>

<h2>
<a id="path-symbols" class="anchor" href="#path-symbols" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Path symbols</h2>

<p>The server.js has a set of 'default path symbols' which are referencable using the $symbol syntax in require strings: '$widgets/myfile',
The default path symbols are:</p>

<pre><code>    'system':'$root/system',
    'resources':'$root/resources',
    'examples':'$root/examples',
    '3d':'$root/classes/3d',
    'behaviors':'$root/classes/behaviors',
    'server':'$root/classes/server',
    'sensors':'$root/classes/sensors',
    'ui':'$root/classes/ui',
    'testing':'$root/classes/testing',
    'widgets':'$root/classes/widgets',
</code></pre>

<p>Adding a path is done using the commandline
node server.js -path mylib:../mydir mylib2:../mydir2</p>

<h2>
<a id="classes" class="anchor" href="#classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Classes</h2>

<p>classes are defined in a single file, using the following syntax:</p>

<pre><code>define.class('$ui/view', function(require, exports, $ui$, label){
    var mylib = require('./mylib')

    this.method = function(){
    }

    exports.staticmethod = function(){
    }
})
</code></pre>

<p>Please note the 'require' syntax to specify the baseclass, and the $ui$ to switch directory in the dependency-class list.
Other syntax: $$ - current directory, relative$dir$</p>

<p>The prototype of the class is the 'this' of the function.
Note the 2 specially named arguments 'require' and 'exports' where they appear
doesnt matter, the name does.
exports is the class constructor function, which can hold the static methods.
require is simply the local instance of require if needed for normal requires.</p>

<p>After the baseclass and dependencies, you can define attributes on a dreemclass.</p>

<h2>
<a id="attributes" class="anchor" href="#attributes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Attributes</h2>

<p>Attributes are properties that can be wired to other properties, and have a type.</p>

<p>The way to create them in a class is to assign an object to this.attributes. The setter of 'attributes' will handle creating all the attributes on the class for you. Types of attributes are automatically inferred if assigned with a plain value, but can also be configured using a Config({meta:'hello'}) object. Assigning a Config object to any existing attribute also refines its settings.
Options for the config attribute are:</p>

<pre><code>    type:vec2,float,String
    value:0.4,vec2(3),"hello"
    meta:'metadataforeditor'
    persist:true // make sure the attribute survives a livereload / rerender
</code></pre>

<pre><code>this.attributes = {
    propfloat: 1.0,
    propstring: "HELLO",
    propcustom: Config({type:vec2})
}
</code></pre>

<p>Attributes are also automatically created if you pass them to the constructor function. view({myprop:10}) automatically creates the myprop attribute</p>

<h2>
<a id="events-and-attributes" class="anchor" href="#events-and-attributes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Events and attributes</h2>

<p>Attributes allow listeners, and this forms the core eventhandling system.
When a value of an attribute changes, using a simple assignment:</p>

<pre><code>this.attr = 10
</code></pre>

<p>This will fire all the listeners to this attribute. Adding listeners to attributes is advised to use the onattr (on prefix) syntax</p>

<pre><code>this.onattr = function(event){
    // event object contains value, old, type, etc
}
</code></pre>

<p>Attribute listeners are called parent-on-up in the prototype hierarchy,
and each prototypelevel only has one 'onattr' slot, since this is a normal property.
Emitting an event on an attribute can be done by assigning to it, but also using the emit syntax. This object goes to all the listeners as an argument</p>

<pre><code>this.emit('attr',{type:'myown'})
</code></pre>

<p>It is also possible to mark values going into a setter using the Mark wrapper.</p>

<pre><code>this.attr = Mark(15, true) // or plainly Mark(15)
</code></pre>

<p>This 'mark' is passed into the event object to all the listener as the mark property. Using this it is possible to break infinite feedback loops like so</p>

<pre><code>this.onattr = function(event){
    if(event.mark) return // someone did an attribute assign using the Mark
}
</code></pre>

<p>It is also possible to use addListener, this adds a list of listeners which are not the same as the onattr (on prefix) slots on the prototype chain. However
this is exceedingly rare</p>

<pre><code>this.addListener('attr', function(event){

})
</code></pre>

<h2>
<a id="styles" class="anchor" href="#styles" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Styles</h2>

<p>Styles are supported using the 'style' property that can live on 4 levels:</p>

<ul>
<li>composition</li>
<li>screen</li>
<li>class</li>
<li>nestedclass</li>
</ul>

<p>These levels are also inherited in that order.
Styles allow subclassing of classes used in the render function of the class on which the properties are set. The subclassing is done using a matching syntax
There are no limitations what you can put in a style since its an actual subclass.</p>

<p>The following style match patterns are supported</p>

<pre><code>this.style = {
    $:{ // match all
    }
    $_myclass:{ // match all with class:'myclass'
    },
    label:{ // match all labels
    }
    label_name:{ // match all labels with name:'name'
    },
    label_class:{ // match all labels with class:'class'
    }
}
</code></pre>

<p>Have fun!</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2>

<p>This software is licensed under the  Apache License, Version 2.0. You will find the terms in the file named
<a href="LICENSE.md">"LICENSE.md"</a> in this directory.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/dreemproject/dreemgl">DreemGL</a> is maintained by <a href="https://github.com/dreemproject">dreemproject</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
